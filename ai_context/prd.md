Of course. Here is the tutorial generated by CodeScribe based on the video you provided.

---

# Building a CRUD Database Agent with PydanticAI and Supabase

## Introduction

Hello! I'm an expert AI developer, and in this tutorial, I'll guide you through building a powerful AI agent that can perform all the basic database operations. We'll be creating an agent that can Create, Retrieve, Update, and Delete (CRUD) records in a database using natural language commands.

This is a fundamental skill for building truly intelligent, enterprise-ready AI systems. By connecting an agent to a database, we transform it from an isolated tool into a data-driven application that is scalable, reliable, and actionable.

We will be using Python with the **PydanticAI** framework to build our agent and **Supabase**, a fantastic open-source platform based on PostgreSQL, for our database.

## Prerequisites

Before we start, make sure you have the following installed and set up:

*   **Python 3.9+**: Ensure you have a recent version of Python installed.
*   **Docker Desktop**: We will use Docker to run a local instance of Supabase easily.
*   **Node.js and npm**: Required to install the Supabase CLI.
*   **Basic Knowledge**: You should have a basic understanding of Python and working with a terminal.
*   **API Keys**:
    *   A free **Groq API Key** for the LLM.
    *   You will get the **Supabase URL and Key** during the local setup process.

## Step-by-Step Guide

### Step 1: Setting Up the Supabase Database Locally

First, let's get our database running. I'll use the Supabase CLI to quickly spin up a local development environment.

1.  **Install the Supabase CLI** via npm. Open your terminal and run:
    ```bash
    npm install supabase --save-dev
    ```

2.  **Initialize a Supabase project** in your working directory:
    ```bash
    npx supabase init
    ```

3.  **Start the Supabase services** using Docker. This command will pull all the necessary container images and start them up.
    ```bash
    npx supabase start
    ```
    Once this process completes, the terminal will output several important URLs and keys. **Make sure to copy the `API URL` and the `anon key`** and save them in a `.env` file in your project root, as we'll need them later.

    ```text
    # .env file
    SUPABASE_URL=http://127.0.0.1:54321
    SUPABASE_KEY=your_anon_key_here
    GROQ_API_KEY=your_groq_key_here
    ```

### Step 2: Creating the Customers Table

With Supabase running, we can now create the table that our agent will manage.

1.  Navigate to the **Studio URL** provided by the CLI (usually `http://127.0.0.1:54323`).
2.  In the Supabase Studio, go to the **Table Editor** icon on the left sidebar.
3.  Click **Create a new table**.
4.  Name the table `customers`.
5.  For this tutorial, **disable "Row Level Security (RLS)"** to simplify our direct API access. In a production environment, you would configure this properly.
6.  Add the following columns:
    *   `full_name` (type: `text`)
    *   `email` (type: `text`)
    *   `bio` (type: `text`)
7.  Click the "gear" icon next to the `email` column to edit it. Go to the "Constraints" section at the bottom and toggle on **"Is Unique"**. This is crucial to prevent duplicate customer entries based on their email.
8.  Click **Save** to create the table.

Our database is now ready!

### Step 3: Building the CRUD Tools

Now for the fun part: writing the Python code for our agent. We will define a function for each CRUD operation and decorate it with `@agent.tool` to make it available to the AI.

These tools will handle the logic for interacting with our Supabase database.

1.  **Create Tool**: This tool will insert a new customer record. It takes the email, full name, and bio as arguments.
    ```python
    @agent.tool(retries=3)
    async def create_customer(ctx: RunContext[Client], email: str, full_name: str, bio: str):
        """Create a customer record from the data provided."""
        try:
            response = (
                ctx.deps.table("customers")
                .insert({"email": email, "full_name": full_name, "bio": bio})
                .execute()
            )
            return response
        except Exception as exception:
            return exception
    ```

2.  **Retrieve Tool**: This tool fetches a customer's details using their email address.
    ```python
    @agent.tool(retries=3)
    async def get_customer_by_email(ctx: RunContext[Client], email: str):
        """Retrieve a customer record from their email address."""
        response = ctx.deps.table("customers").select("*").eq("email", email).execute()
        if response.data:
            return response.data[0]
        else:
            raise ValueError(f"No customer found with email: {email}")
    ```

3.  **Update Tool**: This tool finds a customer by their email and updates their full name and bio.
    ```python
    @agent.tool(retries=3)
    async def update_customer_by_email(ctx: RunContext[Client], email: str, full_name: str, bio: str):
        """Update a customer record from their email address."""
        response = (
            ctx.deps.table("customers")
            .update({"full_name": full_name, "bio": bio})
            .eq("email", email)
            .execute()
        )
        return response
    ```

4.  **Delete Tool**: Finally, this tool deletes a customer record based on their email.
    ```python
    @agent.tool(retries=3)
    async def delete_customer_by_email(ctx: RunContext[Client], email: str):
        """Delete a customer record from their email address."""
        response = ctx.deps.table("customers").delete().eq("email", email).execute()
        return response
    ```

## Complete Code Example

Here is the complete `agent.py` file. It includes all the necessary imports, environment variable loading, the Supabase client setup, the agent and tool definitions, and the main loop to interact with the agent from the terminal.

```python
import os
from dotenv import load_dotenv
from colorama import Fore
from dataclasses import dataclass
from pydantic_ai import Agent, RunContext
from pydantic_ai.models.groq import GroqModel
from supabase import create_client, Client

# Initialize model
load_dotenv()
GROQ_API_KEY: str = os.getenv("GROQ_API_KEY")

# Initialize Supabase client
url: str = os.environ.get("SUPABASE_URL")
key: str = os.environ.get("SUPABASE_KEY")
supabase: Client = create_client(url, key)

# Pydantic model for Customer
@dataclass
class Customer:
    id: str
    email: str
    full_name: str
    bio: str

# Raise error if Groq API key is not found
if not GROQ_API_KEY:
    raise ValueError(Fore.RED + "Groq API key not found. Please set the GROQ_API_KEY environment variable.")

def get_model(model_name:str):
    try:
        model = GroqModel(
            model_name=model_name,
            api_key=GROQ_API_KEY
        )
        return model
    except Exception as e:
        print(Fore.RED + "Error initializing model: ", e)
        model = None
        return model

system_prompt = "You are a customer service agent for a tech company. Use the tools provided to assist customers with their queries."
agent = Agent(model=get_model("llama-3.1-70b-versatile"), result_type=Customer, system_prompt=system_prompt)

# Seed function to create table in Supabase, populate with sample data
def seed_db():
    try:
        response = (
            supabase.table("customers")
            .insert([
                {"email": "johndoe@gmail.com", "full_name": "John Doe", "bio": "I am a software engineer"},
                {"email": "janedoe@gmail.com", "full_name": "Jane Doe", "bio": "I am a data scientist"},
                {"email": "jimdoe@gmail.com", "full_name": "Jim Doe", "bio": "I am a product manager"},
            ])
            .execute()
        )
        return response
    except Exception as exception:
        return exception

# Create Tool
@agent.tool(retries=3)
async def create_customer(ctx: RunContext[Client], email: str, full_name: str, bio: str):
    """Create a customer record from the data provided."""
    try:
        response = (
            ctx.deps.table("customers")
            .insert({"email": email, "full_name": full_name, "bio": bio})
            .execute()
        )
        return response
    except Exception as exception:
        return exception

# Retrieve tool
@agent.tool(retries=3)
async def get_customer_by_email(ctx: RunContext[Client], email: str):
    """Retrieve a customer record from their email address."""
    response = ctx.deps.table("customers").select("*").eq("email", email).execute()
    if response.data:
        return response.data[0]
    else:
        raise ValueError(f"No customer found with email: {email}")

# Update tool
@agent.tool(retries=3)
async def update_customer_by_email(ctx: RunContext[Client], email: str, full_name: str, bio: str):
    """Update a customer record from their email address."""
    response = (
        ctx.deps.table("customers")
        .update({"full_name": full_name, "bio": bio})
        .eq("email", email)
        .execute()
    )
    return response

# Delete tool
@agent.tool(retries=3)
async def delete_customer_by_email(ctx: RunContext[Client], email: str):
    """Delete a customer record from their email address."""
    response = ctx.deps.table("customers").delete().eq("email", email).execute()
    return response

# Define the main loop
def main_loop():
    # Seed the database on startup
    seed_db()

    while True:
        user_input = input(">> Enter a query (q, quit, exit to exit): ")
        if user_input.lower() in ["quit", "exit", "q"]:
            print("Goodbye!")
            break

        try:
            result = agent.run_sync(user_input, deps=supabase)
            print(Fore.YELLOW, result.data)
        except ValueError as e:
            print(Fore.RED, f"No customer found with that email.")
        except Exception as e:
            print(Fore.RED, "An error occurred: ", e)

if __name__ == "__main__":
    main_loop()

```

## Conclusion

Congratulations! You have successfully built a sophisticated AI agent that can intelligently interact with a database. We've covered setting up a Supabase instance, defining a data schema, and implementing the four core CRUD operations as tools for a PydanticAI agent.

From here, you can expand on this foundation by adding more complex tools, integrating it with a web framework like FastAPI to create an API, or building a user interface with Streamlit. You now have the core components for creating truly powerful, data-aware AI applications.
